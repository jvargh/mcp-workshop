"use strict";(self.webpackChunkmcp_workshop=self.webpackChunkmcp_workshop||[]).push([[5170],{1210:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>i,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"mcp-concepts/more/more","title":"There\'s more than tools","description":"On this workshop, we\'ve covered tools, but there are other concepts that are important to understand. In this section, we\'ll cover some of them.","source":"@site/docs/mcp-concepts/03-more/more.md","sourceDirName":"mcp-concepts/03-more","slug":"/mcp-concepts/more/more","permalink":"/mcp-workshop/docs/mcp-concepts/more/more","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/mcp-concepts/03-more/more.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Consuming external servers","permalink":"/mcp-workshop/docs/mcp-concepts/more/external"}}');var s=n(4848),o=n(8453);const a={sidebar_position:2},c="There's more than tools",i={},l=[{value:"Resources",id:"resources",level:2},{value:"Prompts",id:"prompts",level:2}];function p(e){const r={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"theres-more-than-tools",children:"There's more than tools"})}),"\n",(0,s.jsx)(r.p,{children:"On this workshop, we've covered tools, but there are other concepts that are important to understand. In this section, we'll cover some of them."}),"\n",(0,s.jsx)(r.p,{children:"Additionally to tools, there's also"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Resources"}),", which are any type of data that can be used by the server. For example, text files, images or even a database schema."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Prompts"}),", these are templates that can be used to generate a response. As a client, you would then pass specific data to the server and the server would generate a response based on the template."]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"resources",children:"Resources"}),"\n",(0,s.jsx)(r.p,{children:"All of the following are resources:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"File contents"}),"\n",(0,s.jsx)(r.li,{children:"Database records"}),"\n",(0,s.jsx)(r.li,{children:"API responses"}),"\n",(0,s.jsx)(r.li,{children:"Live system data"}),"\n",(0,s.jsx)(r.li,{children:"Screenshots and images"}),"\n",(0,s.jsx)(r.li,{children:"Log files"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Resources are accessed using a URI with the following schema:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-text",children:"[protocol]://[host]/[path]\n"})}),"\n",(0,s.jsx)(r.p,{children:"For example:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-text",children:"file://localhost/path/to/file.txt\r\npostgres://database/customers/schema\n"})}),"\n",(0,s.jsx)(r.p,{children:"Here's how you could implement a resource in your server:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:'\r\n// Static resource\r\nserver.resource(\r\n  "file",\r\n  "file://{path}",\r\n  async (uri, { path }) => {\r\n\r\n    // open file based on `path` and return contents    \r\n\r\n    return {\r\n      contents: [{\r\n        uri: uri.href,\r\n        text: "File content here"\r\n      }]\r\n    };\r\n});\n'})}),"\n",(0,s.jsx)(r.p,{children:"On the client side, you would then add code like so to read the resource:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:'// Read a resource\r\nconst resource = await client.readResource({\r\n  uri: "file:///example.txt"\r\n});\n'})}),"\n",(0,s.jsx)(r.h2,{id:"prompts",children:"Prompts"}),"\n",(0,s.jsx)(r.p,{children:"Prompts, as we stated earlier, are templates that can be used to generate a response. It's convenient to store prompts that you know will product a good response."}),"\n",(0,s.jsx)(r.p,{children:"Here's an example of a prompt:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:'server.prompt(\r\n  "product-prompt", \r\n  "A product query prompt that comes up with a slogan", \r\n  {\r\n    name: z.string(),\r\n    description: z.string()\r\n  }, \r\n  async({ name, description }) => {\r\n    console.log("Received request to generate a product prompt");\r\n    return {\r\n      messages: [{\r\n        role: "user",\r\n        content: {\r\n          type: "text",\r\n          text: `Please come up with a slogan for a product called ${name}. The product is described as: ${description}.`,\r\n        }\r\n      }]\r\n    };\r\n  } \r\n)\n'})}),"\n",(0,s.jsx)(r.p,{children:"Above, we created a prompt that takes a name and description and generates a slogan for the product. The prompt is then used by the server to generate a response."}),"\n",(0,s.jsx)(r.p,{children:"This prompt can now be used by the client to generate a response when the client calls an LLM, like so:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:'// 1. get the prompt from the server\r\n\r\nconst response = client.callPrompt({\r\n  name: "product-prompt",\r\n  arguments: {\r\n    name: "My Product",\r\n    description: "A product that does something"\r\n  }\r\n});\r\n\r\n// 2. call the LLM with the generated response\r\n\r\nresponse.then((result) => {\r\n  console.log("Generated response: ", result);\r\n\r\n  llm.chat.completion({\r\n    messages: result.messages,\r\n    model: "gpt-3.5-turbo",\r\n    temperature: 0.7,\r\n  }).then((response) => {\r\n    console.log("LLM response: ", response);\r\n  });\r\n});\n'})}),"\n",(0,s.jsx)(r.p,{children:"Putting prompts on the server like this offloads the responsibility of generating the prompt to the server, which means your client code can be simpler and cleaner. It also means that you can change the prompt on the server without having to change the client code."}),"\n",(0,s.jsx)(r.p,{children:"Imagine now how someone in the marketing department of an e-commerce using this prompt for new products. They could just call the server with the name and description of the product and get a slogan back. This is a great example of how you can use MCP to create a more efficient workflow."})]})}function h(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>c});var t=n(6540);const s={},o=t.createContext(s);function a(e){const r=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:r},e.children)}}}]);