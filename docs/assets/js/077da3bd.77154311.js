"use strict";(self.webpackChunkmcp_workshop=self.webpackChunkmcp_workshop||[]).push([[5891],{5670:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>i,contentTitle:()=>c,default:()=>l,frontMatter:()=>a,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"mcp-concepts/sse-server/sse","title":"Servers with SSE","description":"The stdio transport, that you\'ve been using so far, enables communication through standard input and output streams. This is particularly useful for local integrations and command-line tools.","source":"@site/docs/mcp-concepts/02-sse-server/sse.md","sourceDirName":"mcp-concepts/02-sse-server","slug":"/mcp-concepts/sse-server/sse","permalink":"/mcp-workshop/docs/mcp-concepts/sse-server/sse","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/mcp-concepts/02-sse-server/sse.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"SSE Servers","permalink":"/mcp-workshop/docs/category/sse-servers"},"next":{"title":"Activity: Create an SSE server","permalink":"/mcp-workshop/docs/mcp-concepts/sse-server/activity-see"}}');var n=r(4848),o=r(8453);const a={sidebar_position:1},c="Servers with SSE",i={},p=[];function d(e){const s={a:"a",code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"servers-with-sse",children:"Servers with SSE"})}),"\n",(0,n.jsx)(s.p,{children:"The stdio transport, that you've been using so far, enables communication through standard input and output streams. This is particularly useful for local integrations and command-line tools."}),"\n",(0,n.jsxs)(s.p,{children:["Now, we will cover SSE ",(0,n.jsx)(s.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events",children:"Server-Sent Events (SSE)"})," transport. SSE is a standard for server-to-client streaming, allowing servers to push real-time updates to clients over HTTP. This is particularly useful for applications that require live updates, such as chat applications, notifications, or real-time data feeds. Also, your server can be used by multiple clients at the same time as it lives on a server that can be run somewhere in the cloud for example."]}),"\n",(0,n.jsx)(s.p,{children:"Here's what such a server can look like:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-typescript",children:'import express, { Request, Response } from "express";\r\nimport { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";\r\nimport { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";\r\n\r\nconst server = new McpServer({\r\n  name: "example-server",\r\n  version: "1.0.0"\r\n});\r\n\r\n// ... set up server resources, tools, and prompts ...\r\n\r\nconst app = express();\r\n\r\n// to support multiple simultaneous connections we have a lookup object from\r\n// sessionId to transport\r\nconst transports: {[sessionId: string]: SSEServerTransport} = {};\r\n\r\napp.get("/sse", async (_: Request, res: Response) => {\r\n  const transport = new SSEServerTransport(\'/messages\', res);\r\n  transports[transport.sessionId] = transport;\r\n  res.on("close", () => {\r\n    delete transports[transport.sessionId];\r\n  });\r\n  await server.connect(transport);\r\n});\r\n\r\napp.post("/messages", async (req: Request, res: Response) => {\r\n  const sessionId = req.query.sessionId as string;\r\n  const transport = transports[sessionId];\r\n  if (transport) {\r\n    await transport.handlePostMessage(req, res);\r\n  } else {\r\n    res.status(400).send(\'No transport found for sessionId\');\r\n  }\r\n});\r\n\r\napp.listen(3001);\n'})}),"\n",(0,n.jsx)(s.p,{children:"In the preceding code we set up an Express server that listens to two endpoints:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"/sse"}),": This endpoint is used to establish a connection with the server. When a client connects to this endpoint, a new ",(0,n.jsx)(s.code,{children:"SSEServerTransport"})," instance is created and added to the ",(0,n.jsx)(s.code,{children:"transports"})," object. The server then calls ",(0,n.jsx)(s.code,{children:"server.connect(transport)"})," to start receiving messages from the client."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"/messages"}),": This endpoint is used to handle incoming messages from the client. When a message is received, the server looks up the corresponding ",(0,n.jsx)(s.code,{children:"SSEServerTransport"})," instance in the ",(0,n.jsx)(s.code,{children:"transports"})," object and calls ",(0,n.jsx)(s.code,{children:"transport.handlePostMessage(req, res)"})," to process the message."]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Now that we understand what SSE is, how to create such a server, let's practice it in the next activity."})]})}function l(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,s,r)=>{r.d(s,{R:()=>a,x:()=>c});var t=r(6540);const n={},o=t.createContext(n);function a(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);